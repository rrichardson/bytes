var searchIndex = {};
searchIndex["bytes"] = {"doc":"","items":[[3,"ByteBuf","bytes","A `Buf` backed by a contiguous region of memory.",null,null],[3,"MutByteBuf","","",null,null],[3,"RingBuf","","Buf backed by a continous chunk of memory. Maintains a read cursor and a\nwrite cursor. When reads and writes reach the end of the allocated buffer,\nwraps around to the start.",null,null],[3,"ROByteBuf","","Same as `ByteBuf` but cannot be flipped to a `MutByteBuf`.",null,null],[3,"SliceBuf","","",null,null],[3,"MutSliceBuf","","",null,null],[3,"Take","","",null,null],[3,"Bytes","","A specialized `ByteStr` box.",null,null],[3,"Rope","","An immutable sequence of bytes formed by concatenation of other `ByteStr`\nvalues, without copying the data in the pieces. The concatenation is\nrepresented as a tree whose leaf nodes are each a `Bytes` value.",null,null],[3,"RopeBuf","","",null,null],[3,"SeqByteStr","","",null,null],[3,"SmallByteStr","","",null,null],[3,"SmallByteStrBuf","","",null,null],[4,"BufError","","",null,null],[13,"Underflow","","",0,null],[13,"Overflow","","",0,null],[0,"alloc","","",null,null],[3,"Heap","bytes::alloc","",null,null],[3,"Pool","","",null,null],[3,"MemRef","","",null,null],[5,"heap","","",null,{"inputs":[{"name":"usize"}],"output":{"name":"memref"}}],[11,"allocate","","",1,null],[11,"with_capacity","","Constructs a new `Pool` with with specified capacity such that each\nbuffer in the pool has a length of `buf_len`.",2,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"pool"}}],[11,"capacity","","Returns the number of buffers that the `Pool` holds.",2,null],[11,"new_byte_buf","","Returns a new `ByteBuf` backed by a buffer from the pool. If the pool\nis depleted, `None` is returned.",2,null],[11,"new_append_buf","","",2,null],[8,"Mem","","",null,null],[10,"ref_inc","","Increment the ref count",3,null],[10,"ref_dec","","Decrement the ref count",3,null],[11,"new","","",4,null],[11,"none","","",4,{"inputs":[],"output":{"name":"memref"}}],[11,"is_none","","",4,null],[11,"len","","",4,null],[11,"bytes","","",4,null],[11,"bytes_mut","","",4,null],[11,"clone","","",4,null],[11,"drop","","",4,null],[0,"buf","bytes","",null,null],[3,"AppendBuf","bytes::buf","A `Buf` backed by a contiguous region of memory.",null,null],[3,"ByteBuf","","A `Buf` backed by a contiguous region of memory.",null,null],[3,"MutByteBuf","","",null,null],[3,"ROByteBuf","","Same as `ByteBuf` but cannot be flipped to a `MutByteBuf`.",null,null],[3,"RingBuf","","Buf backed by a continous chunk of memory. Maintains a read cursor and a\nwrite cursor. When reads and writes reach the end of the allocated buffer,\nwraps around to the start.",null,null],[3,"SliceBuf","","",null,null],[3,"MutSliceBuf","","",null,null],[3,"Take","","",null,null],[11,"with_capacity","","",5,{"inputs":[{"name":"u32"}],"output":{"name":"appendbuf"}}],[11,"none","","Returns an AppendBuf with no capacity",5,{"inputs":[],"output":{"name":"appendbuf"}}],[11,"from_mem_ref","","",5,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"}],"output":{"name":"appendbuf"}}],[11,"bytes","","",5,null],[11,"shift","","",5,null],[11,"slice","","",5,null],[11,"remaining","","",5,null],[11,"advance","","",5,null],[11,"mut_bytes","","",5,null],[11,"from_slice","bytes","Create a new `ByteBuf` by copying the contents of the given slice.",6,null],[11,"mut_with_capacity","","",6,{"inputs":[{"name":"usize"}],"output":{"name":"mutbytebuf"}}],[11,"none","","",6,{"inputs":[],"output":{"name":"bytebuf"}}],[11,"from_mem_ref","","",6,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"bytebuf"}}],[11,"capacity","","",6,null],[11,"flip","","",6,null],[11,"resume","","Flips the buffer back to mutable, resetting the write position\nto the byte after the previous write.",6,null],[11,"read_slice","","",6,null],[11,"to_seq_byte_str","","",6,null],[11,"to_bytes","","",6,null],[11,"mark","","Marks the current read location.",6,null],[11,"reset","","Resets the read position to the previously marked position.",6,null],[11,"remaining","","",6,null],[11,"bytes","","",6,null],[11,"advance","","",6,null],[11,"read_slice","","",6,null],[11,"fmt","","",6,null],[11,"from_mem_ref","","",7,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"robytebuf"}}],[11,"to_seq_byte_str","","",7,null],[11,"to_bytes","","",7,null],[11,"mark","","Marks the current read location.",7,null],[11,"reset","","Resets the read position to the previously marked position.",7,null],[11,"remaining","","",7,null],[11,"bytes","","",7,null],[11,"advance","","",7,null],[11,"read_slice","","",7,null],[11,"fmt","","",7,null],[11,"capacity","","",8,null],[11,"flip","","",8,null],[11,"clear","","",8,null],[11,"write_slice","","",8,null],[11,"bytes","","",8,null],[11,"remaining","","",8,null],[11,"advance","","",8,null],[11,"mut_bytes","","",8,null],[11,"fmt","","",8,null],[11,"new","","Allocates a new `RingBuf` with the specified capacity.",9,{"inputs":[{"name":"usize"}],"output":{"name":"ringbuf"}}],[11,"is_full","","Returns `true` if the buf cannot accept any further writes.",9,null],[11,"is_empty","","Returns `true` if the buf cannot accept any further reads.",9,null],[11,"capacity","","Returns the number of bytes that the buf can hold.",9,null],[11,"mark","","Marks the current read location.",9,null],[11,"reset","","Resets the read position to the previously marked position.",9,null],[11,"clear","","Resets all internal state to the initial state.",9,null],[11,"fmt","","",9,null],[11,"remaining","","",9,null],[11,"bytes","","",9,null],[11,"advance","","",9,null],[11,"remaining","","",9,null],[11,"advance","","",9,null],[11,"mut_bytes","","",9,null],[11,"wrap","","",10,null],[11,"remaining","","",10,null],[11,"bytes","","",10,null],[11,"advance","","",10,null],[11,"wrap","","",11,null],[11,"remaining","","",11,null],[11,"advance","","",11,null],[11,"mut_bytes","","",11,null],[11,"fmt","","",12,null],[11,"new","","",12,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"take"}}],[11,"into_inner","","",12,null],[11,"get_ref","","",12,null],[11,"get_mut","","",12,null],[11,"limit","","",12,null],[11,"set_limit","","",12,null],[11,"remaining","","",12,null],[11,"bytes","","",12,null],[11,"advance","","",12,null],[11,"read","","",12,null],[11,"remaining","","",12,null],[11,"mut_bytes","","",12,null],[11,"advance","","",12,null],[8,"Buf","bytes::buf","A trait for values that provide sequential read access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",13,null],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",13,null],[10,"advance","","Advance the internal cursor of the Buf",13,null],[11,"has_remaining","","Returns true if there are any more bytes to consume",13,null],[11,"copy_to","","",13,null],[11,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.\nReturns the number of bytes read.",13,null],[11,"read_byte","","Read a single byte from the `Buf`",13,null],[8,"MutBuf","","A trait for values that provide sequential write access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be written to the MutBuf",14,null],[10,"advance","","Advance the internal cursor of the MutBuf",14,null],[11,"has_remaining","","Returns true iff there is any more space for bytes to be written",14,null],[10,"mut_bytes","","Returns a mutable slice starting at the current MutBuf position and of\nlength between 0 and `MutBuf::remaining()`.",14,null],[11,"copy_from","","",14,null],[11,"write_slice","","Write bytes from the given slice into the `MutBuf` and advance the\ncursor by the number of bytes written.\nReturns the number of bytes written.",14,null],[8,"Source","","A value that writes bytes from itself into a `MutBuf`.",null,null],[10,"copy_to","","",15,null],[8,"Sink","","",null,null],[10,"copy_from","","",16,null],[8,"ReadExt","","",null,null],[10,"read_buf","","",17,null],[8,"WriteExt","","",null,null],[10,"write_buf","","",18,null],[11,"read","bytes","",6,null],[11,"read","","",7,null],[11,"read","","",19,null],[11,"write","","",8,null],[11,"flush","","",8,null],[0,"str","","",null,null],[3,"Bytes","bytes::str","A specialized `ByteStr` box.",null,null],[3,"Rope","","An immutable sequence of bytes formed by concatenation of other `ByteStr`\nvalues, without copying the data in the pieces. The concatenation is\nrepresented as a tree whose leaf nodes are each a `Bytes` value.",null,null],[3,"RopeBuf","","",null,null],[3,"SeqByteStr","","",null,null],[3,"SmallByteStr","","",null,null],[3,"SmallByteStrBuf","","",null,null],[11,"from_slice","bytes","",20,null],[11,"of","","",20,{"inputs":[{"name":"b"}],"output":{"name":"bytes"}}],[11,"empty","","",20,{"inputs":[],"output":{"name":"bytes"}}],[11,"downcast_ref","","If the underlying `ByteStr` is of type `B`, returns a reference to it\notherwise None.",20,null],[11,"try_unwrap","","If the underlying `ByteStr` is of type `B`, returns the unwraped value,\notherwise, returns the original `Bytes` as `Err`.",20,null],[11,"buf","","",20,null],[11,"concat","","",20,null],[11,"len","","",20,null],[11,"slice","","",20,null],[11,"split_at","","",20,null],[11,"to_bytes","","",20,null],[11,"index","","",20,null],[11,"fmt","","",20,null],[11,"clone","","",20,null],[11,"drop","","",20,null],[11,"from_slice","","",21,null],[11,"of","","Returns a Rope consisting of the supplied Bytes as a single segment.",21,{"inputs":[{"name":"b"}],"output":{"name":"rope"}}],[11,"len","","",21,null],[11,"is_empty","","",21,null],[11,"buf","","",21,null],[11,"concat","","",21,null],[11,"len","","",21,null],[11,"slice","","",21,null],[11,"to_bytes","","",21,null],[11,"index","","",21,null],[11,"clone","","",21,null],[11,"remaining","","",19,null],[11,"bytes","","",19,null],[11,"advance","","",19,null],[11,"from_slice","","Create a new `SeqByteStr` from a byte slice.",22,null],[11,"from_mem_ref","","Creates a new `SeqByteStr` from a `MemRef`, an offset, and a length.",22,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"}],"output":{"name":"seqbytestr"}}],[11,"buf","","",22,null],[11,"concat","","",22,null],[11,"len","","",22,null],[11,"slice","","",22,null],[11,"to_bytes","","",22,null],[11,"index","","",22,null],[11,"clone","","",22,null],[11,"clone","","",23,null],[11,"zero","","",23,{"inputs":[],"output":{"name":"smallbytestr"}}],[11,"from_slice","","",23,null],[11,"as_slice","","",23,null],[11,"buf","","",23,null],[11,"concat","","",23,null],[11,"len","","",23,null],[11,"slice","","",23,null],[11,"to_bytes","","",23,null],[11,"index","","",23,null],[11,"clone","","",24,null],[11,"remaining","","",24,null],[11,"bytes","","",24,null],[11,"advance","","",24,null],[8,"ByteStr","bytes::str","An immutable sequence of bytes. Operations will not mutate the original\nvalue. Since only immutable access is permitted, operations do not require\ncopying (though, sometimes copying will happen as an optimization).",null,null],[16,"Buf","","",25,null],[10,"buf","","Returns a read-only `Buf` for accessing the byte contents of the\n`ByteStr`.",25,null],[10,"concat","","Returns a new `Bytes` value representing the concatenation of `self`\nwith the given `Bytes`.",25,null],[10,"len","","Returns the number of bytes in the ByteStr",25,null],[11,"is_empty","","Returns true if the length of the `ByteStr` is 0",25,null],[10,"slice","","Returns a new ByteStr value containing the byte range between `begin`\n(inclusive) and `end` (exclusive)",25,null],[11,"slice_from","","Returns a new ByteStr value containing the byte range starting from\n`begin` (inclusive) to the end of the byte str.",25,null],[11,"slice_to","","Returns a new ByteStr value containing the byte range from the start up\nto `end` (exclusive).",25,null],[11,"split_at","","Divides the value into two `Bytes` at the given index.",25,null],[8,"ToBytes","","",null,null],[10,"to_bytes","","Consumes the value and returns a `Bytes` instance containing\nidentical bytes",26,null],[11,"eq","bytes","",22,null],[11,"ne","","",22,null],[11,"eq","","",23,null],[11,"ne","","",23,null],[11,"eq","","",20,null],[11,"ne","","",20,null],[11,"eq","","",21,null],[11,"ne","","",21,null],[11,"fmt","","",0,null],[11,"clone","","",0,null]],"paths":[[4,"BufError"],[3,"Heap"],[3,"Pool"],[8,"Mem"],[3,"MemRef"],[3,"AppendBuf"],[3,"ByteBuf"],[3,"ROByteBuf"],[3,"MutByteBuf"],[3,"RingBuf"],[3,"SliceBuf"],[3,"MutSliceBuf"],[3,"Take"],[8,"Buf"],[8,"MutBuf"],[8,"Source"],[8,"Sink"],[8,"ReadExt"],[8,"WriteExt"],[3,"RopeBuf"],[3,"Bytes"],[3,"Rope"],[3,"SeqByteStr"],[3,"SmallByteStr"],[3,"SmallByteStrBuf"],[8,"ByteStr"],[8,"ToBytes"]]};
initSearch(searchIndex);
