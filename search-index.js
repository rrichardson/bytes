var searchIndex = {};
searchIndex["bytes"] = {"doc":"","items":[[3,"Fmt","bytes","",null,null],[12,"0","","",0,null],[3,"AppendBuf","","A `Buf` backed by a contiguous region of memory.",null,null],[3,"BlockBuf","","Append only buffer backed by a chain of `AppendBuf` buffers.",null,null],[3,"BlockBufCursor","","",null,null],[3,"ByteBuf","","A `Buf` backed by a contiguous region of memory.",null,null],[3,"MutByteBuf","","",null,null],[3,"RingBuf","","Buf backed by a continous chunk of memory. Maintains a read cursor and a\nwrite cursor. When reads and writes reach the end of the allocated buffer,\nwraps around to the start.",null,null],[3,"Take","","",null,null],[3,"Bytes","","",null,null],[11,"with_capacity","","",1,{"inputs":[{"name":"u32"}],"output":{"name":"appendbuf"}}],[11,"from_mem_ref","","",1,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"}],"output":{"name":"appendbuf"}}],[11,"len","","",1,null],[11,"capacity","","",1,null],[11,"bytes","","",1,null],[11,"shift","","",1,null],[11,"drop","","",1,null],[11,"slice","","",1,null],[11,"remaining","","",1,null],[11,"has_remaining","","",1,null],[11,"advance","","",1,null],[11,"mut_bytes","","",1,null],[11,"as_ref","","",1,null],[11,"new","","Create BlockBuf",2,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"blockbuf"}}],[11,"len","","Returns the number of buffered bytes",2,null],[11,"is_empty","","Returns true if there are no buffered bytes",2,null],[11,"buf","","Returns a `Buf` for the currently buffered bytes.",2,null],[11,"shift","","Consumes `n` buffered bytes, returning them as an immutable `Bytes`\nvalue.",2,null],[11,"drop","","Drop the first `n` buffered bytes",2,null],[11,"is_compact","","",2,null],[11,"compact","","Moves all buffered bytes into a single block.",2,null],[11,"bytes","","Return byte slice if bytes are in sequential memory",2,null],[11,"remaining","","",2,null],[11,"has_remaining","","",2,null],[11,"advance","","",2,null],[11,"mut_bytes","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"blockbuf"}}],[11,"remaining","","",3,null],[11,"bytes","","",3,null],[11,"advance","","",3,null],[11,"from_slice","","Create a new `ByteBuf` by copying the contents of the given slice.",4,null],[11,"from_mem_ref","","",4,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"bytebuf"}}],[11,"capacity","","",4,null],[11,"flip","","",4,null],[11,"resume","","Flips the buffer back to mutable, resetting the write position\nto the byte after the previous write.",4,null],[11,"read_slice","","",4,null],[11,"mark","","Marks the current read location.",4,null],[11,"reset","","Resets the read position to the previously marked position.",4,null],[11,"remaining","","",4,null],[11,"bytes","","",4,null],[11,"advance","","",4,null],[11,"read_slice","","",4,null],[11,"from","","",5,{"inputs":[{"name":"bytebuf"}],"output":{"name":"bytes"}}],[11,"fmt","","",4,null],[11,"with_capacity","","",6,{"inputs":[{"name":"usize"}],"output":{"name":"mutbytebuf"}}],[11,"capacity","","",6,null],[11,"flip","","",6,null],[11,"clear","","",6,null],[11,"write_slice","","",6,null],[11,"bytes","","",6,null],[11,"remaining","","",6,null],[11,"advance","","",6,null],[11,"mut_bytes","","",6,null],[11,"fmt","","",6,null],[11,"new","","Allocates a new `RingBuf` with the specified capacity.",7,{"inputs":[{"name":"usize"}],"output":{"name":"ringbuf"}}],[11,"is_full","","Returns `true` if the buf cannot accept any further writes.",7,null],[11,"is_empty","","Returns `true` if the buf cannot accept any further reads.",7,null],[11,"capacity","","Returns the number of bytes that the buf can hold.",7,null],[11,"mark","","Marks the current read location.",7,null],[11,"reset","","Resets the read position to the previously marked position.",7,null],[11,"clear","","Resets all internal state to the initial state.",7,null],[11,"fmt","","",7,null],[11,"remaining","","",7,null],[11,"bytes","","",7,null],[11,"advance","","",7,null],[11,"remaining","","",7,null],[11,"advance","","",7,null],[11,"mut_bytes","","",7,null],[11,"fmt","","",8,null],[11,"new","","",8,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"take"}}],[11,"into_inner","","",8,null],[11,"get_ref","","",8,null],[11,"get_mut","","",8,null],[11,"limit","","",8,null],[11,"set_limit","","",8,null],[11,"remaining","","",8,null],[11,"bytes","","",8,null],[11,"advance","","",8,null],[11,"remaining","","",8,null],[11,"mut_bytes","","",8,null],[11,"advance","","",8,null],[11,"copy_to","","",5,null],[11,"write_str","","",0,null],[11,"write_fmt","","",0,null],[11,"clone","","",5,null],[11,"empty","","Return an empty `Bytes`",5,{"inputs":[],"output":{"name":"bytes"}}],[11,"from_mem_ref","","Creates a new `Bytes` from a `MemRef`, an offset, and a length.",5,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"}],"output":{"name":"bytes"}}],[11,"buf","","",5,null],[11,"is_empty","","",5,null],[11,"len","","",5,null],[11,"concat","","",5,null],[11,"slice","","Returns a new ByteStr value containing the byte range between `begin`\n(inclusive) and `end` (exclusive)",5,null],[11,"slice_from","","Returns a new ByteStr value containing the byte range starting from\n`begin` (inclusive) to the end of the byte str.",5,null],[11,"slice_to","","Returns a new ByteStr value containing the byte range from the start up\nto `end` (exclusive).",5,null],[11,"index","","",5,null],[11,"from","","",5,{"inputs":[{"name":"t"}],"output":{"name":"bytes"}}],[11,"eq","","",5,null],[11,"ne","","",5,null],[11,"fmt","","",5,null],[0,"alloc","","",null,null],[3,"MemRef","bytes::alloc","",null,null],[5,"heap","","Allocate a segment of memory and return a `MemRef`.",null,{"inputs":[{"name":"usize"}],"output":{"name":"memref"}}],[11,"new","","",9,{"inputs":[{"name":"arc"}],"output":{"name":"memref"}}],[11,"len","","",9,null],[11,"bytes","","",9,null],[11,"bytes_slice","","",9,null],[11,"mut_bytes","","",9,null],[11,"mut_bytes_slice","","Unsafe, unchecked access to the bytes",9,null],[11,"clone","","",9,null],[8,"Buf","bytes","A trait for values that provide sequential read access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",10,null],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",10,null],[10,"advance","","Advance the internal cursor of the Buf",10,null],[11,"has_remaining","","Returns true if there are any more bytes to consume",10,null],[11,"copy_to","","",10,null],[11,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.\nReturns the number of bytes read.",10,null],[11,"read_byte","","Read a single byte from the `Buf`",10,null],[11,"peek_byte","","",10,null],[8,"MutBuf","","A trait for values that provide sequential write access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be written to the MutBuf",11,null],[10,"advance","","Advance the internal cursor of the MutBuf",11,null],[11,"has_remaining","","Returns true iff there is any more space for bytes to be written",11,null],[10,"mut_bytes","","Returns a mutable slice starting at the current MutBuf position and of\nlength between 0 and `MutBuf::remaining()`.",11,null],[11,"copy_from","","",11,null],[11,"write_slice","","Write bytes from the given slice into the `MutBuf` and advance the\ncursor by the number of bytes written.\nReturns the number of bytes written.",11,null],[11,"write_str","","",11,null],[8,"Source","","A value that writes bytes from itself into a `MutBuf`.",null,null],[10,"copy_to","","",12,null],[8,"Sink","","",null,null],[10,"copy_from","","",13,null],[8,"ReadExt","","",null,null],[10,"read_buf","","",14,null],[8,"WriteExt","","",null,null],[10,"write_buf","","",15,null],[11,"has_remaining","","Returns true if there are any more bytes to consume",10,null],[11,"copy_to","","",10,null],[11,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.\nReturns the number of bytes read.",10,null],[11,"read_byte","","Read a single byte from the `Buf`",10,null],[11,"peek_byte","","",10,null],[11,"has_remaining","","Returns true iff there is any more space for bytes to be written",11,null],[11,"copy_from","","",11,null],[11,"write_slice","","Write bytes from the given slice into the `MutBuf` and advance the\ncursor by the number of bytes written.\nReturns the number of bytes written.",11,null],[11,"write_str","","",11,null]],"paths":[[3,"Fmt"],[3,"AppendBuf"],[3,"BlockBuf"],[3,"BlockBufCursor"],[3,"ByteBuf"],[3,"Bytes"],[3,"MutByteBuf"],[3,"RingBuf"],[3,"Take"],[3,"MemRef"],[8,"Buf"],[8,"MutBuf"],[8,"Source"],[8,"Sink"],[8,"ReadExt"],[8,"WriteExt"]]};
initSearch(searchIndex);
