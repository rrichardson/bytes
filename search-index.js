var searchIndex = {};
searchIndex["bytes"] = {"doc":"","items":[[3,"Fmt","bytes","",null,null],[12,"0","","",0,null],[3,"AppendBuf","","A `Buf` backed by a contiguous region of memory.",null,null],[3,"BlockBuf","","Append only buffer backed by a chain of `AppendBuf` buffers.",null,null],[3,"BlockBufCursor","","",null,null],[3,"ByteBuf","","A `Buf` backed by a contiguous region of memory.",null,null],[3,"MutByteBuf","","",null,null],[3,"RingBuf","","Buf backed by a continous chunk of memory. Maintains a read cursor and a\nwrite cursor. When reads and writes reach the end of the allocated buffer,\nwraps around to the start.",null,null],[3,"Take","","",null,null],[3,"Bytes","","",null,null],[4,"NewBlock","","",null,null],[13,"Heap","","",1,null],[13,"Pool","","",1,null],[11,"with_capacity","","",2,{"inputs":[{"name":"u32"}],"output":{"name":"appendbuf"}}],[11,"none","","Returns an AppendBuf with no capacity",2,{"inputs":[],"output":{"name":"appendbuf"}}],[11,"from_mem_ref","","",2,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"}],"output":{"name":"appendbuf"}}],[11,"len","","",2,null],[11,"capacity","","",2,null],[11,"bytes","","",2,null],[11,"shift","","",2,null],[11,"drop","","",2,null],[11,"slice","","",2,null],[11,"remaining","","",2,null],[11,"has_remaining","","",2,null],[11,"advance","","",2,null],[11,"mut_bytes","","",2,null],[11,"as_ref","","",2,null],[11,"new","","Create BlockBuf",3,{"inputs":[{"name":"usize"},{"name":"newblock"}],"output":{"name":"blockbuf"}}],[11,"len","","Returns the number of buffered bytes",3,null],[11,"is_empty","","Returns true if there are no buffered bytes",3,null],[11,"buf","","Returns a `Buf` for the currently buffered bytes.",3,null],[11,"shift","","Consumes `n` buffered bytes, returning them as an immutable `Bytes`\nvalue.",3,null],[11,"drop","","Drop the first `n` buffered bytes",3,null],[11,"compact","","Moves all buffered bytes into a single block.",3,null],[11,"bytes","","Return byte slice if bytes are in sequential memory",3,null],[11,"remaining","","",3,null],[11,"has_remaining","","",3,null],[11,"advance","","",3,null],[11,"mut_bytes","","",3,null],[11,"default","","",3,{"inputs":[],"output":{"name":"blockbuf"}}],[11,"remaining","","",4,null],[11,"bytes","","",4,null],[11,"advance","","",4,null],[11,"from_slice","","Create a new `ByteBuf` by copying the contents of the given slice.",5,null],[11,"mut_with_capacity","","",5,{"inputs":[{"name":"usize"}],"output":{"name":"mutbytebuf"}}],[11,"none","","",5,{"inputs":[],"output":{"name":"bytebuf"}}],[11,"from_mem_ref","","",5,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"},{"name":"u32"}],"output":{"name":"bytebuf"}}],[11,"capacity","","",5,null],[11,"flip","","",5,null],[11,"resume","","Flips the buffer back to mutable, resetting the write position\nto the byte after the previous write.",5,null],[11,"read_slice","","",5,null],[11,"mark","","Marks the current read location.",5,null],[11,"reset","","Resets the read position to the previously marked position.",5,null],[11,"remaining","","",5,null],[11,"bytes","","",5,null],[11,"advance","","",5,null],[11,"read_slice","","",5,null],[11,"from","","",6,{"inputs":[{"name":"bytebuf"}],"output":{"name":"bytes"}}],[11,"fmt","","",5,null],[11,"capacity","","",7,null],[11,"flip","","",7,null],[11,"clear","","",7,null],[11,"write_slice","","",7,null],[11,"bytes","","",7,null],[11,"remaining","","",7,null],[11,"advance","","",7,null],[11,"mut_bytes","","",7,null],[11,"fmt","","",7,null],[11,"new","","Allocates a new `RingBuf` with the specified capacity.",8,{"inputs":[{"name":"usize"}],"output":{"name":"ringbuf"}}],[11,"is_full","","Returns `true` if the buf cannot accept any further writes.",8,null],[11,"is_empty","","Returns `true` if the buf cannot accept any further reads.",8,null],[11,"capacity","","Returns the number of bytes that the buf can hold.",8,null],[11,"mark","","Marks the current read location.",8,null],[11,"reset","","Resets the read position to the previously marked position.",8,null],[11,"clear","","Resets all internal state to the initial state.",8,null],[11,"fmt","","",8,null],[11,"remaining","","",8,null],[11,"bytes","","",8,null],[11,"advance","","",8,null],[11,"remaining","","",8,null],[11,"advance","","",8,null],[11,"mut_bytes","","",8,null],[11,"fmt","","",9,null],[11,"new","","",9,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"take"}}],[11,"into_inner","","",9,null],[11,"get_ref","","",9,null],[11,"get_mut","","",9,null],[11,"limit","","",9,null],[11,"set_limit","","",9,null],[11,"remaining","","",9,null],[11,"bytes","","",9,null],[11,"advance","","",9,null],[11,"remaining","","",9,null],[11,"mut_bytes","","",9,null],[11,"advance","","",9,null],[11,"copy_to","","",6,null],[11,"write_str","","",0,null],[11,"write_fmt","","",0,null],[11,"clone","","",6,null],[11,"empty","","Return an empty `Bytes`",6,{"inputs":[],"output":{"name":"bytes"}}],[11,"from_mem_ref","","Creates a new `Bytes` from a `MemRef`, an offset, and a length.",6,{"inputs":[{"name":"memref"},{"name":"u32"},{"name":"u32"}],"output":{"name":"bytes"}}],[11,"buf","","",6,null],[11,"is_empty","","",6,null],[11,"len","","",6,null],[11,"concat","","",6,null],[11,"slice","","Returns a new ByteStr value containing the byte range between `begin`\n(inclusive) and `end` (exclusive)",6,null],[11,"slice_from","","Returns a new ByteStr value containing the byte range starting from\n`begin` (inclusive) to the end of the byte str.",6,null],[11,"slice_to","","Returns a new ByteStr value containing the byte range from the start up\nto `end` (exclusive).",6,null],[11,"index","","",6,null],[11,"from","","",6,{"inputs":[{"name":"t"}],"output":{"name":"bytes"}}],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"fmt","","",6,null],[0,"alloc","","",null,null],[3,"Pool","bytes::alloc","",null,null],[3,"MemRef","","",null,null],[5,"heap","","Allocate a segment of memory and return a `MemRef`.",null,{"inputs":[{"name":"usize"}],"output":{"name":"memref"}}],[11,"with_capacity","","Constructs a new `Pool` with with specified capacity such that each\nbuffer in the pool has a length of `buf_len`.",10,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"pool"}}],[11,"capacity","","Returns the number of buffers that the `Pool` holds.",10,null],[11,"buffer_len","","Returns the size of buffers allocated by the pool",10,null],[11,"new_byte_buf","","Returns a new `ByteBuf` backed by a buffer from the pool. If the pool\nis depleted, `None` is returned.",10,null],[11,"new_append_buf","","",10,null],[8,"Mem","","Ref-counted segment of memory",null,null],[10,"ref_inc","","Increment the ref count",11,null],[10,"ref_dec","","Decrement the ref count",11,null],[11,"new","","",12,null],[11,"none","","",12,{"inputs":[],"output":{"name":"memref"}}],[11,"is_none","","",12,null],[11,"len","","",12,null],[11,"bytes","","",12,null],[11,"bytes_slice","","",12,null],[11,"mut_bytes","","",12,null],[11,"mut_bytes_slice","","Unsafe, unchecked access to the bytes",12,null],[11,"clone","","",12,null],[11,"drop","","",12,null],[8,"Buf","bytes","A trait for values that provide sequential read access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be accessed from the Buf",13,null],[10,"bytes","","Returns a slice starting at the current Buf position and of length\nbetween 0 and `Buf::remaining()`.",13,null],[10,"advance","","Advance the internal cursor of the Buf",13,null],[11,"has_remaining","","Returns true if there are any more bytes to consume",13,null],[11,"copy_to","","",13,null],[11,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.\nReturns the number of bytes read.",13,null],[11,"read_byte","","Read a single byte from the `Buf`",13,null],[11,"peek_byte","","",13,null],[8,"MutBuf","","A trait for values that provide sequential write access to bytes.",null,null],[10,"remaining","","Returns the number of bytes that can be written to the MutBuf",14,null],[10,"advance","","Advance the internal cursor of the MutBuf",14,null],[11,"has_remaining","","Returns true iff there is any more space for bytes to be written",14,null],[10,"mut_bytes","","Returns a mutable slice starting at the current MutBuf position and of\nlength between 0 and `MutBuf::remaining()`.",14,null],[11,"copy_from","","",14,null],[11,"write_slice","","Write bytes from the given slice into the `MutBuf` and advance the\ncursor by the number of bytes written.\nReturns the number of bytes written.",14,null],[11,"write_str","","",14,null],[8,"Source","","A value that writes bytes from itself into a `MutBuf`.",null,null],[10,"copy_to","","",15,null],[8,"Sink","","",null,null],[10,"copy_from","","",16,null],[8,"ReadExt","","",null,null],[10,"read_buf","","",17,null],[8,"WriteExt","","",null,null],[10,"write_buf","","",18,null],[11,"has_remaining","","Returns true if there are any more bytes to consume",13,null],[11,"copy_to","","",13,null],[11,"read_slice","","Read bytes from the `Buf` into the given slice and advance the cursor by\nthe number of bytes read.\nReturns the number of bytes read.",13,null],[11,"read_byte","","Read a single byte from the `Buf`",13,null],[11,"peek_byte","","",13,null],[11,"has_remaining","","Returns true iff there is any more space for bytes to be written",14,null],[11,"copy_from","","",14,null],[11,"write_slice","","Write bytes from the given slice into the `MutBuf` and advance the\ncursor by the number of bytes written.\nReturns the number of bytes written.",14,null],[11,"write_str","","",14,null]],"paths":[[3,"Fmt"],[4,"NewBlock"],[3,"AppendBuf"],[3,"BlockBuf"],[3,"BlockBufCursor"],[3,"ByteBuf"],[3,"Bytes"],[3,"MutByteBuf"],[3,"RingBuf"],[3,"Take"],[3,"Pool"],[8,"Mem"],[3,"MemRef"],[8,"Buf"],[8,"MutBuf"],[8,"Source"],[8,"Sink"],[8,"ReadExt"],[8,"WriteExt"]]};
initSearch(searchIndex);
